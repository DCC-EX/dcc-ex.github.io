{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DCC++ EX An open-source hardware and software platform for the operation of DCC-equipped model railroads. Welcome to the DCC++ EX website. DCC++ EX is an open-source hardware and software platform for the operation of DCC-equipped model railroads. It is based on Gregg E. Berman's DCC++ code. DCC-EX picks up where the original DCC++ left off. By addressing some previous issues, we have released what we now call \"DCC++ Classic\" - everything you enjoyed in the original version in a stable release. In addition, we have have continued development with an all new version called \"DCC-EX\" that includes enhancements and upgrades. We intend to organize this all in one place so that development can continue and the platform can adjust to new hardware and technnology. Our Mission Our mission is to open the world of model railroading and make it universally accesible. In order to achieve that, DCC++ EX is providing the model railroad community with a complete, open source DCC (Digital Command Control) system - one that is simple, affordable, and expandable, to control model trains and accessories. Further, it is our goal that this project be organized, documented, and maintained so that it can continue far into the future. What is DCC++ EX? In addition to controlling your trains, DCC++ also includes advanced features such as dedicated logic for operating turnouts, and the ability to create and control your own digital inputs, digital outputs, and even analog inputs --- great for reading panel switches, sensors, and occupancy detectors, as well as controlling servos, LEDS, and anything else you can imagine! Basically, DCC-EX can control anything using a DCC signal over two tracks, two wires, or via wired Ethernet or WiFi. A basic DCC++ EX system can use easy to find, widely avalable Arduino boards that you can plug in yourself. You may even have one sitting around in your project drawer! Or, you can use our FireBox Control Station for something that is just plug-and-play. DCC++ supports the full set of NMRA Digital Command and Control (DCC) standards , including: simultaneous control of multiple locomotives 2-byte and 4-byte locomotive addressing 128-step speed throttling Activate/de-activate all accessory function addresses 0-2048 Control of all cab functions F0-F28 Main Track: Write configuration variable bytes and set/clear specific configuration variable (CV) bits Programming Track: Same as the main track with the addition of reading configuration variable bytes What's new in DCC++ EX? Complete support for all the old commands and front ends like JMRI Direct support for all the most popular motor control boards I2C Display support Improved short circuit detection and automatic reset from an overload Current reading, sensing and ACK detection settings in milliAmps instead of just pin readings Improved adherence to the NMRA DCC specification New Communication Manager to handle input and output to multiple sources simultaneously (JMRI, Cab controllers, etc.) Arduino Network Shield and ESP8266 WiFi support Railcom Cutout (Beta) Simpler, modular, faster code with an API Library for developers for easy expansion No more jumpers or soldering! (Beta) New features and functionsn in JMRI (coming) Automation (Alpha) NOTE: The Next release will be a major rewrite to the code. We started from scratch and are rebuilding from the ground up! For what that means to you, click HERE . The system consists of multiple parts: Base Station - An Arduino, motorboard and the DCC-EX uploadable firmware Controller - The JMRI Train Controlling and Decoder Programming Software Track Power Supply - A DC power supply to provide power to the rails Computer - You supply a laptop or other computer to run JMRI and connect via a USB cable to the Arduino DCC++ EX Software - The DCC++ EX sofware (called a \"sketch\") loaded onto the Arduino There are many flavors and options to choose from. The DCC-EX system is incredibly expandable and adaptable. However, to keep it simple we will be covering a \"Starter System\" and providing you with a Quick Start guide to get you going. There is a more detailed User Manual for those who want to dig deeper and explore other options. The manual covers other motor control boards, other controllers, wireless communication options, current sensing options, using a Raspberry Pi instead of a laptop, and more. You aren't limited to just one or two choices and we've got you covered if you want to put together the perfect system for you.","title":"Home"},{"location":"#welcome-to-dcc-ex","text":"An open-source hardware and software platform for the operation of DCC-equipped model railroads. Welcome to the DCC++ EX website. DCC++ EX is an open-source hardware and software platform for the operation of DCC-equipped model railroads. It is based on Gregg E. Berman's DCC++ code. DCC-EX picks up where the original DCC++ left off. By addressing some previous issues, we have released what we now call \"DCC++ Classic\" - everything you enjoyed in the original version in a stable release. In addition, we have have continued development with an all new version called \"DCC-EX\" that includes enhancements and upgrades. We intend to organize this all in one place so that development can continue and the platform can adjust to new hardware and technnology.","title":"Welcome to DCC++ EX"},{"location":"#our-mission","text":"Our mission is to open the world of model railroading and make it universally accesible. In order to achieve that, DCC++ EX is providing the model railroad community with a complete, open source DCC (Digital Command Control) system - one that is simple, affordable, and expandable, to control model trains and accessories. Further, it is our goal that this project be organized, documented, and maintained so that it can continue far into the future.","title":"Our Mission"},{"location":"#what-is-dcc-ex","text":"In addition to controlling your trains, DCC++ also includes advanced features such as dedicated logic for operating turnouts, and the ability to create and control your own digital inputs, digital outputs, and even analog inputs --- great for reading panel switches, sensors, and occupancy detectors, as well as controlling servos, LEDS, and anything else you can imagine! Basically, DCC-EX can control anything using a DCC signal over two tracks, two wires, or via wired Ethernet or WiFi. A basic DCC++ EX system can use easy to find, widely avalable Arduino boards that you can plug in yourself. You may even have one sitting around in your project drawer! Or, you can use our FireBox Control Station for something that is just plug-and-play. DCC++ supports the full set of NMRA Digital Command and Control (DCC) standards , including: simultaneous control of multiple locomotives 2-byte and 4-byte locomotive addressing 128-step speed throttling Activate/de-activate all accessory function addresses 0-2048 Control of all cab functions F0-F28 Main Track: Write configuration variable bytes and set/clear specific configuration variable (CV) bits Programming Track: Same as the main track with the addition of reading configuration variable bytes","title":"What is DCC++ EX?"},{"location":"#whats-new-in-dcc-ex","text":"Complete support for all the old commands and front ends like JMRI Direct support for all the most popular motor control boards I2C Display support Improved short circuit detection and automatic reset from an overload Current reading, sensing and ACK detection settings in milliAmps instead of just pin readings Improved adherence to the NMRA DCC specification New Communication Manager to handle input and output to multiple sources simultaneously (JMRI, Cab controllers, etc.) Arduino Network Shield and ESP8266 WiFi support Railcom Cutout (Beta) Simpler, modular, faster code with an API Library for developers for easy expansion No more jumpers or soldering! (Beta) New features and functionsn in JMRI (coming) Automation (Alpha) NOTE: The Next release will be a major rewrite to the code. We started from scratch and are rebuilding from the ground up! For what that means to you, click HERE .","title":"What's new in DCC++ EX?"},{"location":"#the-system-consists-of-multiple-parts","text":"Base Station - An Arduino, motorboard and the DCC-EX uploadable firmware Controller - The JMRI Train Controlling and Decoder Programming Software Track Power Supply - A DC power supply to provide power to the rails Computer - You supply a laptop or other computer to run JMRI and connect via a USB cable to the Arduino DCC++ EX Software - The DCC++ EX sofware (called a \"sketch\") loaded onto the Arduino There are many flavors and options to choose from. The DCC-EX system is incredibly expandable and adaptable. However, to keep it simple we will be covering a \"Starter System\" and providing you with a Quick Start guide to get you going. There is a more detailed User Manual for those who want to dig deeper and explore other options. The manual covers other motor control boards, other controllers, wireless communication options, current sensing options, using a Raspberry Pi instead of a laptop, and more. You aren't limited to just one or two choices and we've got you covered if you want to put together the perfect system for you.","title":"The system consists of multiple parts:"},{"location":"about/about-us/","text":"The DCC++ EX Project Who is behind all this? And will they ever face justice? Who knows, but the following is a list of those names associated with taking over the DCC++ Base Station Project and advancing it into the future. First, a special thanks to Gregg E. Berman who had the original idea for a model railroad Base Station using an Arduino Uno and a Motor Shield. If you want to read a short history of the project and what's changed over the years, click HERE (TODO - Create a link for this) What you see available for download here represents a complete rewrite of the code and the concept of what we (and what you tell us) DCC++ EX needs to be. You can seek us out here: TrainBoard DCC++ Forum Our Discord Server You can get support for DCC++ EX at either of the above links including live support on Discord. Names below in parenthesis are screen names on Trainboard and Discord Project Lead Fred Decker - Holly Springs, North Carolina, USA (FlightRisk) DCC++ EX Lead Developers David Cutting - Park City, Utah, USA (David Cutting) Chris Harlow - Bournemouth UK (UKBloke) Developers Harald Barth Stockholm - Sweden (Haba) Fred Decker - Holly Springs, North Carolina, USA (FlightRisk) Gregor Baues - \u00cele-de-France France (grbba) DCC++ Classic Lead Developers Mike Dunston - Sonora, California, USA (Atani) Fred Decker - Holly Springs, North Carolina USA (FlightRisk) Installer Software Lead Developers Anthony W - Dayton, Ohio USA (Dex, Dex++) Website Lead Developers Mani Kumar - Bangalor India (Mani / Mani Kumar) Fred Decker - Holly Springs, North Carolina, USA (FlightRisk) Developers David Cutting - Park City, Utah, USA (David Cutting) Fred Decker - Holly Springs, North Carolina USA (FlightRisk) Documentation / Management Roger Beschizza - Dorset UK (Roger Beschizza) Keith Ledbetter - Chicago, Illinois USA (Keith Ledbetter) Kevin Smith - (KCSmith) Testing / Research / Support Sumner Patterson - Blanding, Utah, USA (Sumner) Larry Dribin - (H0Guy) Paul - Virginia USA (Paul1361) Gregor Baues - \u00cele-de-France France (grbba)","title":" "},{"location":"about/about-us/#the-dcc-ex-project","text":"Who is behind all this? And will they ever face justice? Who knows, but the following is a list of those names associated with taking over the DCC++ Base Station Project and advancing it into the future. First, a special thanks to Gregg E. Berman who had the original idea for a model railroad Base Station using an Arduino Uno and a Motor Shield. If you want to read a short history of the project and what's changed over the years, click HERE (TODO - Create a link for this) What you see available for download here represents a complete rewrite of the code and the concept of what we (and what you tell us) DCC++ EX needs to be. You can seek us out here: TrainBoard DCC++ Forum Our Discord Server You can get support for DCC++ EX at either of the above links including live support on Discord. Names below in parenthesis are screen names on Trainboard and Discord","title":"The DCC++ EX Project"},{"location":"about/about-us/#project-lead","text":"Fred Decker - Holly Springs, North Carolina, USA (FlightRisk)","title":"Project Lead"},{"location":"about/about-us/#dcc-ex","text":"","title":"DCC++ EX"},{"location":"about/about-us/#lead-developers","text":"David Cutting - Park City, Utah, USA (David Cutting) Chris Harlow - Bournemouth UK (UKBloke)","title":"Lead Developers"},{"location":"about/about-us/#developers","text":"Harald Barth Stockholm - Sweden (Haba) Fred Decker - Holly Springs, North Carolina, USA (FlightRisk) Gregor Baues - \u00cele-de-France France (grbba)","title":"Developers"},{"location":"about/about-us/#dcc-classic","text":"","title":"DCC++ Classic"},{"location":"about/about-us/#lead-developers_1","text":"Mike Dunston - Sonora, California, USA (Atani) Fred Decker - Holly Springs, North Carolina USA (FlightRisk)","title":"Lead Developers"},{"location":"about/about-us/#installer-software","text":"","title":"Installer Software"},{"location":"about/about-us/#lead-developers_2","text":"Anthony W - Dayton, Ohio USA (Dex, Dex++)","title":"Lead Developers"},{"location":"about/about-us/#website","text":"","title":"Website"},{"location":"about/about-us/#lead-developers_3","text":"Mani Kumar - Bangalor India (Mani / Mani Kumar) Fred Decker - Holly Springs, North Carolina, USA (FlightRisk)","title":"Lead Developers"},{"location":"about/about-us/#developers_1","text":"David Cutting - Park City, Utah, USA (David Cutting) Fred Decker - Holly Springs, North Carolina USA (FlightRisk)","title":"Developers"},{"location":"about/about-us/#documentation-management","text":"Roger Beschizza - Dorset UK (Roger Beschizza) Keith Ledbetter - Chicago, Illinois USA (Keith Ledbetter) Kevin Smith - (KCSmith)","title":"Documentation / Management"},{"location":"about/about-us/#testing-research-support","text":"Sumner Patterson - Blanding, Utah, USA (Sumner) Larry Dribin - (H0Guy) Paul - Virginia USA (Paul1361) Gregor Baues - \u00cele-de-France France (grbba)","title":"Testing / Research / Support"},{"location":"api/command-station-api/","text":"Command Station API Work in progress","title":"Command Station"},{"location":"api/command-station-api/#command-station-api","text":"Work in progress","title":"Command Station API"},{"location":"develop/base-station-dev/","text":"Base Station Development Work in progress","title":"Base Station"},{"location":"develop/base-station-dev/#base-station-development","text":"Work in progress","title":"Base Station Development"},{"location":"download/dccex-downloads/","text":"Download DCC++ EX Welcome to the DCC++ EX download page. You have several choices depending on what you want to do with DCC-EX. I you aren't a programmer, or a tinkerer, or you just want to installer to do the work for you, choose the installer download. If you want to download a zip file, extract the files and use the Arduino IDE to install the firmware onto your board, choose one of the options below. If you are a developer and want to install the software into a repository on your computer, select the GitHub Repository option. Automated DCC++ EX / DCC++ Classic Installer Automated Installer Clicking above will open a page containing instructions and the download link for the DCC-EX installer. You will have the opportunity to select either DCC++ \"Classic\" or the new DCC++ EX. The installer will let you select options, such as your Arduino board type, motor shield/motor controller, and COM port and then automatically compile the firmware and upload it to your Arduino or compatible board. Latest DCC++ EX Release Download Zip DCC++ EX Download Zip Clicking above will immediately download a zip file containing the Arduino Sketch file for DCC++ EX. You will need either the Arduino IDE (found here) or the PlatformIO development environment (found here) in order to upload it to your microcontroller board. DCC++ EX GitHub Repository DCC++ EX GitHub Repository Clicking above will take you the the DCC++ EX GitHub repository where you can download the project as a Zip file or Clone it to your own respository. All of the source files and instructions for how to contribute to the project can be found in the repository. We have made sure that you can still use the Arduino IDE if you like, but we recommend devlopers use the PlaformIO development environment. The Original \"Classic\" version The installer at the top of the page will give you the choice of either version. We recommend using the newer DCC++ EX version. But if you are looking for the original source for the project (with some minor bug fixes and improvements), click the links below. NOTE: This version is not actively maintained and will only be updated with bug fixes. Last DCC++ Classic Release Download Zip DCC++ Classic GitHub Repository","title":"DCC++ Basestation"},{"location":"download/dccex-downloads/#download-dcc-ex","text":"Welcome to the DCC++ EX download page. You have several choices depending on what you want to do with DCC-EX. I you aren't a programmer, or a tinkerer, or you just want to installer to do the work for you, choose the installer download. If you want to download a zip file, extract the files and use the Arduino IDE to install the firmware onto your board, choose one of the options below. If you are a developer and want to install the software into a repository on your computer, select the GitHub Repository option.","title":"Download DCC++ EX"},{"location":"download/dccex-downloads/#automated-dcc-ex-dcc-classic-installer","text":"Automated Installer Clicking above will open a page containing instructions and the download link for the DCC-EX installer. You will have the opportunity to select either DCC++ \"Classic\" or the new DCC++ EX. The installer will let you select options, such as your Arduino board type, motor shield/motor controller, and COM port and then automatically compile the firmware and upload it to your Arduino or compatible board.","title":"Automated DCC++ EX / DCC++ Classic Installer"},{"location":"download/dccex-downloads/#latest-dcc-ex-release-download-zip","text":"DCC++ EX Download Zip Clicking above will immediately download a zip file containing the Arduino Sketch file for DCC++ EX. You will need either the Arduino IDE (found here) or the PlatformIO development environment (found here) in order to upload it to your microcontroller board.","title":"Latest DCC++ EX Release Download Zip"},{"location":"download/dccex-downloads/#dcc-ex-github-repository","text":"DCC++ EX GitHub Repository Clicking above will take you the the DCC++ EX GitHub repository where you can download the project as a Zip file or Clone it to your own respository. All of the source files and instructions for how to contribute to the project can be found in the repository. We have made sure that you can still use the Arduino IDE if you like, but we recommend devlopers use the PlaformIO development environment.","title":"DCC++ EX GitHub Repository"},{"location":"download/dccex-downloads/#the-original-classic-version","text":"The installer at the top of the page will give you the choice of either version. We recommend using the newer DCC++ EX version. But if you are looking for the original source for the project (with some minor bug fixes and improvements), click the links below. NOTE: This version is not actively maintained and will only be updated with bug fixes. Last DCC++ Classic Release Download Zip DCC++ Classic GitHub Repository","title":"The Original \"Classic\" version"},{"location":"download/dccex-materials-downloads/","text":"Download DCC++ EX Materials Work in progress","title":"Materials"},{"location":"download/dccex-materials-downloads/#download-dcc-ex-materials","text":"Work in progress","title":"Download DCC++ EX Materials"},{"location":"hardware/i2c-displays/","text":"I2C Displays DCC++ EX is designed to accommodate a display. You don't need a display since the Control Station is often hidden away under the layout. However, if you like the idea of a nice visual display for your panel, just about any I2C (serial to parallel interface) display will work. We recommend either a 20 character by 2 line or 4 line display. The code is easily configurable in order to change the display settings, as well as add or change what is printed on the display.","title":"I2C Displays"},{"location":"hardware/i2c-displays/#i2c-displays","text":"DCC++ EX is designed to accommodate a display. You don't need a display since the Control Station is often hidden away under the layout. However, if you like the idea of a nice visual display for your panel, just about any I2C (serial to parallel interface) display will work. We recommend either a 20 character by 2 line or 4 line display. The code is easily configurable in order to change the display settings, as well as add or change what is printed on the display.","title":"I2C Displays"},{"location":"hardware/microcontrollers/","text":"Microcontrollers DCC++ EX is compatible with many Arduino microcontollers. Out of the box, EX will work by making one selection: Arduino Uno Arduino Mega Arduino Nano We recommend the Mega board since it is inexpensive (you can buy clone boards for under $10 US), it has a lot more GPIO (General Purpose Input/Output) pins so you can expand and connect more sensors, turnouts, leds and accessories, and it has more memory. If you intend to add options like neworking, an I2C Display or anything that adds to the size of the program, you may need the extra memory. And here is an Elegoo version:","title":"Microcontrollers"},{"location":"hardware/microcontrollers/#microcontrollers","text":"DCC++ EX is compatible with many Arduino microcontollers. Out of the box, EX will work by making one selection: Arduino Uno Arduino Mega Arduino Nano We recommend the Mega board since it is inexpensive (you can buy clone boards for under $10 US), it has a lot more GPIO (General Purpose Input/Output) pins so you can expand and connect more sensors, turnouts, leds and accessories, and it has more memory. If you intend to add options like neworking, an I2C Display or anything that adds to the size of the program, you may need the extra memory. And here is an Elegoo version:","title":"Microcontrollers"},{"location":"hardware/motor-boards/","text":"Motor boards There are many motor boards available to use with DCC++ EX. Also called \"Dual-H Bridges\" and \"Motor Shields\", some require a little work, but others are mostly plug and play. NOTE: We recommend the Arduino Motor Shield R3 or a supported clone board like the Deek-Robot ($15 US). Boards currently supported Arduino Motor Shield R3 Deek-Robot Motor Shield LMD18200 Motor Driver Module Pololu MC33926 Motor Shield LMD18200 Based Motor Boards There are other boards, some requiring modification, which are covered in the advanced section. Connecting an Arduino or Deek-Robot Motor Shield Jumper Diagrams The link above will open a PDF document that provides detail information on how to connect the most popular motor controllers to an Arduino.","title":"Motor Boards"},{"location":"hardware/motor-boards/#motor-boards","text":"There are many motor boards available to use with DCC++ EX. Also called \"Dual-H Bridges\" and \"Motor Shields\", some require a little work, but others are mostly plug and play. NOTE: We recommend the Arduino Motor Shield R3 or a supported clone board like the Deek-Robot ($15 US).","title":"Motor boards"},{"location":"hardware/motor-boards/#boards-currently-supported","text":"Arduino Motor Shield R3 Deek-Robot Motor Shield LMD18200 Motor Driver Module Pololu MC33926 Motor Shield LMD18200 Based Motor Boards There are other boards, some requiring modification, which are covered in the advanced section.","title":"Boards currently supported"},{"location":"hardware/motor-boards/#connecting-an-arduino-or-deek-robot-motor-shield","text":"Jumper Diagrams The link above will open a PDF document that provides detail information on how to connect the most popular motor controllers to an Arduino.","title":"Connecting an Arduino or Deek-Robot Motor Shield"},{"location":"hardware/power-supplies/","text":"Power Supplies The power supply is one of the most important parts of your setup. You need to select a clean, filtered power supply that can supply at least the amount of current required by your motor drivers. Voltage N and Z scale layouts should run at at about 12V to avoid damage to the motors. See this thread to learn more about the pros and cons of running at higher voltages at this Trainboard Thread Another good link (along with just about anything written by Mark Gurries, is here: Mark Gurries - Choosing the Right Booster Most larger scales will run higher voltages. For reference, the Digitrax systems put the rails at around 14V. Do some homework to determine what voltage is best for your system. Amperage You'll need to be able to supply 3A per channel to the tracks on which you intend to run trains, assuming you're using the Arduino motor shield or Pololu motor shield. For larger motor driver shields, you'll want a larger power supply. Recommended Power Supplies Wall warts are a good choice for beginners and those not comfortable with mains wiring. You can get a 12V, 3A, relatively small one for around $8 US. You can also find plenty of laptop type \"brick\" power supplies. They come in ranges from 12V to 18V and 3-5 Amps. The Meanwell LRS-100-15 power supply is a good choice for larger scales. It supplies 15V and 105W (that's 7 amps), so it is plenty for running two channels simutaneously. At only $18, it is an inexpensive and solid option. https://www.digikey.com/product-detail/en/mean-well-usa-inc/LRS-100-15/1866-3313-ND/7705005 You'll need to do your own mains wiring, if you don't have experience with this get a friend who does or hire an electrician to do it for you. MAINS POWER IS DANGEROUS.","title":"Power Supplies"},{"location":"hardware/power-supplies/#power-supplies","text":"The power supply is one of the most important parts of your setup. You need to select a clean, filtered power supply that can supply at least the amount of current required by your motor drivers.","title":"Power Supplies"},{"location":"hardware/power-supplies/#voltage","text":"N and Z scale layouts should run at at about 12V to avoid damage to the motors. See this thread to learn more about the pros and cons of running at higher voltages at this Trainboard Thread Another good link (along with just about anything written by Mark Gurries, is here: Mark Gurries - Choosing the Right Booster Most larger scales will run higher voltages. For reference, the Digitrax systems put the rails at around 14V. Do some homework to determine what voltage is best for your system.","title":"Voltage"},{"location":"hardware/power-supplies/#amperage","text":"You'll need to be able to supply 3A per channel to the tracks on which you intend to run trains, assuming you're using the Arduino motor shield or Pololu motor shield. For larger motor driver shields, you'll want a larger power supply.","title":"Amperage"},{"location":"hardware/power-supplies/#recommended-power-supplies","text":"Wall warts are a good choice for beginners and those not comfortable with mains wiring. You can get a 12V, 3A, relatively small one for around $8 US. You can also find plenty of laptop type \"brick\" power supplies. They come in ranges from 12V to 18V and 3-5 Amps. The Meanwell LRS-100-15 power supply is a good choice for larger scales. It supplies 15V and 105W (that's 7 amps), so it is plenty for running two channels simutaneously. At only $18, it is an inexpensive and solid option. https://www.digikey.com/product-detail/en/mean-well-usa-inc/LRS-100-15/1866-3313-ND/7705005 You'll need to do your own mains wiring, if you don't have experience with this get a friend who does or hire an electrician to do it for you. MAINS POWER IS DANGEROUS.","title":"Recommended Power Supplies"},{"location":"notes/rewrite/","text":"What's New for the DCC++ EX Project Everything you loved is still there First, we want to stress that we didn't break anything! Whether you are using JMRI as a front end to send commands to your track, handle turnouts or read and write CVs, or any using any other software or the serial monitor, the commands are still the same. We have expanded the API (Application Programming Interface) to add new commands and provide new responses, but they won't affect your old control methods. One example of a new command is the one to handle turning power on and off to individual tracks. DCC++ EX is all new! While we made minor changes to the original DCC++ \"Classic\", all new development in going forward with DCC++ EX. At first, we expanded features, added functionality and fixed bugs by working from the existing code base. The first release of DCC++ will be familiar to any of you who played with the code. However, we want to stress that the next release, the one that is in Beta testing now, is a complete re-write fromt he ground up. What's different? We started with the DCC Signal Generation code, what we call the \"Waveform Generator. We got together as a team and looked at how we could make it better. It soon became clear that rather than make piecemeal changes, the entire concept of how the signal could be generated and how to use timers and interrupts would need to be re-thought. Next we focused on packet generation. We looked at the complexities of reading and maintaining code that was using binary math, multiple \"registers\" to hold train data, and doing bit shifting everywhere to build bytes and stuff them into data packets. The new method gets rid of the old registers and simplifies the whole structure for building packets. Things like start and stop bits and preamble bits are static pieces of information. Do being able to just insert them where they need to go saves time and processor bandwidth. We created an internal API for how modules communicated with each other. So the code is more modular and each unit is dedicated to its specific task. We completely re-wrote current sense and ACK detect routines. We created an automation scripting language called TPL (Train Programming Language) Why did we do this? We needed a platform that would allow us to grow into the future. The first thing we found was that in order to allow easy changes and to be able to adapt to technology we might want to use going forward, the code needed to be more modular. Each unit needed to be a \"black box\" that either did just one task and do it well, or take input and generate output without having to know anything about the module it was communiating with. Therefore, we created an interal API through which the modules could communicate. By simply unplugging one unit and plugging in another we could continue to work using a differnt devices. An example of this is input and output. It doesn't matter whether JMRI is sending commands to DCC++ EX or if it is a wireless Cab Controller. It doesn't matter if the output device is the serial monitor or an I2C display. It doesn't matter if you want to use a serial port or a network device to route data. This makes it very easy to implement new features with new devices. We just have to create a small interface for whatever new device we want to implement. This has the side benefit of allowing the code to be more readable. Next, the Waveform Generator needed 2 intetimers and interrupts, one for the Main track signal and one for the Programming track. The Uno only has 3 timers. So 2 of them were already tied up for sending the DCC signal. Since the programming track sits idle most of the time, and both signals were always being generated to the input of the motor board, processing power was being wasted that could be put to use for something else. In addition, because of the way the Arduino is designed, we were forced to use jumpers to connect pins on the Arduino to those on the motor board. Our new design eliminates the need for jumpers! The packet generation routine was complex, hard to maintain, and limited us with regard to the hardware we could run on and new features we could implement (like the Railcom cut-out_. We replaced the slow DigitalRead() and DigitalWrite() routines with a fast write library. The packet generation is now streamlined, fast (which allows us to be able to use on only 1 timer to create signals for 2 tracks) and much easier to read. The 3 most requested features were: 1. More reliable CV read and writes, 2. Railcom cut-out, 3. Automation. We haven't limited ourselves to just these features, but we put a lot of time into redesigning things to accomodate them. The current detection routines are completely different. One key difference is all current readings is in milliAmps instead of meaningless pin readings. So if you want to set your overload protection to kick in at 3 Amps, you just enter 3000 for 3000 milliAmps instead of looking up a value from a table. We are still testing all the motorboard and Arduino combinations at different voltages to refine our current readings. This is important because we want to have accurate and fast short-circuit detection, and because the reason CV reading was occasionally unreliable in the past was due to not always sensing a current pulse on the track. In addition to more accurately reading current, we had to completely change the way we look for an \"ACK\" (acknowledgement from the train that it received a command). So we now check immedately after we send a command instead of waiting for a dozen or more packets. This means we don't miss an ACK while this is happening and we jump out of sending uneccessary packes as soon as we get one. You will appreciate how much faster we can read CVs now! We not only have created a rail-com cutout within the Command Station, but are looking at actually reading the Railcom data and reporting it. We may require the use of a Mega instead of an Uno for this feature. TPL brings new capability to the world of automation. You don't have to be a programmer to write a script that tells a train to start moving forward at a set speed until some action (like reaching a sensor) occurs. We will be providing a document and tutorial on TPL once Beta testing is complete. This will be an open-ended project since who knows what people will come up with they want to automate. It will be easy to extend the commands to handle whatever your imagination can dream of. The bottom line So while maintaining proper deference to Gregg Bermann's original concept of an inexpensive Control Station based on the Arduino platform, we don't want to do a disservice to DCC++ EX or develpers like Chris Harlow (UkBloke) and David Codding (David Codding) who brought a new vision to the project and who used very little of the original code. This is NOT DCC++ v2.0, this is a completely new, yet API and feature compatible Control Station. And just a tease: What Constrol Station would be complete without a wireless Cab Controller that speaks DCC++? Keep looking at our web page for new announcments. Thanks This is a team effort. There are a dedicated and organize group of about 15-20 core people involved in the project. In addition, there is all of you who contribute with your comments, feature ideas, evangelizing and testing. So we give you our heartfelt thanks. We will see you online! Click here for The DCC++ EX Team Credits","title":"What's New Details"},{"location":"notes/rewrite/#whats-new-for-the-dcc-ex-project","text":"","title":"What's New for the DCC++ EX Project"},{"location":"notes/rewrite/#everything-you-loved-is-still-there","text":"First, we want to stress that we didn't break anything! Whether you are using JMRI as a front end to send commands to your track, handle turnouts or read and write CVs, or any using any other software or the serial monitor, the commands are still the same. We have expanded the API (Application Programming Interface) to add new commands and provide new responses, but they won't affect your old control methods. One example of a new command is the one to handle turning power on and off to individual tracks.","title":"Everything you loved is still there"},{"location":"notes/rewrite/#dcc-ex-is-all-new","text":"While we made minor changes to the original DCC++ \"Classic\", all new development in going forward with DCC++ EX. At first, we expanded features, added functionality and fixed bugs by working from the existing code base. The first release of DCC++ will be familiar to any of you who played with the code. However, we want to stress that the next release, the one that is in Beta testing now, is a complete re-write fromt he ground up.","title":"DCC++ EX is all new!"},{"location":"notes/rewrite/#whats-different","text":"We started with the DCC Signal Generation code, what we call the \"Waveform Generator. We got together as a team and looked at how we could make it better. It soon became clear that rather than make piecemeal changes, the entire concept of how the signal could be generated and how to use timers and interrupts would need to be re-thought. Next we focused on packet generation. We looked at the complexities of reading and maintaining code that was using binary math, multiple \"registers\" to hold train data, and doing bit shifting everywhere to build bytes and stuff them into data packets. The new method gets rid of the old registers and simplifies the whole structure for building packets. Things like start and stop bits and preamble bits are static pieces of information. Do being able to just insert them where they need to go saves time and processor bandwidth. We created an internal API for how modules communicated with each other. So the code is more modular and each unit is dedicated to its specific task. We completely re-wrote current sense and ACK detect routines. We created an automation scripting language called TPL (Train Programming Language)","title":"What's different?"},{"location":"notes/rewrite/#why-did-we-do-this","text":"We needed a platform that would allow us to grow into the future. The first thing we found was that in order to allow easy changes and to be able to adapt to technology we might want to use going forward, the code needed to be more modular. Each unit needed to be a \"black box\" that either did just one task and do it well, or take input and generate output without having to know anything about the module it was communiating with. Therefore, we created an interal API through which the modules could communicate. By simply unplugging one unit and plugging in another we could continue to work using a differnt devices. An example of this is input and output. It doesn't matter whether JMRI is sending commands to DCC++ EX or if it is a wireless Cab Controller. It doesn't matter if the output device is the serial monitor or an I2C display. It doesn't matter if you want to use a serial port or a network device to route data. This makes it very easy to implement new features with new devices. We just have to create a small interface for whatever new device we want to implement. This has the side benefit of allowing the code to be more readable. Next, the Waveform Generator needed 2 intetimers and interrupts, one for the Main track signal and one for the Programming track. The Uno only has 3 timers. So 2 of them were already tied up for sending the DCC signal. Since the programming track sits idle most of the time, and both signals were always being generated to the input of the motor board, processing power was being wasted that could be put to use for something else. In addition, because of the way the Arduino is designed, we were forced to use jumpers to connect pins on the Arduino to those on the motor board. Our new design eliminates the need for jumpers! The packet generation routine was complex, hard to maintain, and limited us with regard to the hardware we could run on and new features we could implement (like the Railcom cut-out_. We replaced the slow DigitalRead() and DigitalWrite() routines with a fast write library. The packet generation is now streamlined, fast (which allows us to be able to use on only 1 timer to create signals for 2 tracks) and much easier to read. The 3 most requested features were: 1. More reliable CV read and writes, 2. Railcom cut-out, 3. Automation. We haven't limited ourselves to just these features, but we put a lot of time into redesigning things to accomodate them. The current detection routines are completely different. One key difference is all current readings is in milliAmps instead of meaningless pin readings. So if you want to set your overload protection to kick in at 3 Amps, you just enter 3000 for 3000 milliAmps instead of looking up a value from a table. We are still testing all the motorboard and Arduino combinations at different voltages to refine our current readings. This is important because we want to have accurate and fast short-circuit detection, and because the reason CV reading was occasionally unreliable in the past was due to not always sensing a current pulse on the track. In addition to more accurately reading current, we had to completely change the way we look for an \"ACK\" (acknowledgement from the train that it received a command). So we now check immedately after we send a command instead of waiting for a dozen or more packets. This means we don't miss an ACK while this is happening and we jump out of sending uneccessary packes as soon as we get one. You will appreciate how much faster we can read CVs now! We not only have created a rail-com cutout within the Command Station, but are looking at actually reading the Railcom data and reporting it. We may require the use of a Mega instead of an Uno for this feature. TPL brings new capability to the world of automation. You don't have to be a programmer to write a script that tells a train to start moving forward at a set speed until some action (like reaching a sensor) occurs. We will be providing a document and tutorial on TPL once Beta testing is complete. This will be an open-ended project since who knows what people will come up with they want to automate. It will be easy to extend the commands to handle whatever your imagination can dream of.","title":"Why did we do this?"},{"location":"notes/rewrite/#the-bottom-line","text":"So while maintaining proper deference to Gregg Bermann's original concept of an inexpensive Control Station based on the Arduino platform, we don't want to do a disservice to DCC++ EX or develpers like Chris Harlow (UkBloke) and David Codding (David Codding) who brought a new vision to the project and who used very little of the original code. This is NOT DCC++ v2.0, this is a completely new, yet API and feature compatible Control Station. And just a tease: What Constrol Station would be complete without a wireless Cab Controller that speaks DCC++? Keep looking at our web page for new announcments.","title":"The bottom line"},{"location":"notes/rewrite/#thanks","text":"This is a team effort. There are a dedicated and organize group of about 15-20 core people involved in the project. In addition, there is all of you who contribute with your comments, feature ideas, evangelizing and testing. So we give you our heartfelt thanks. We will see you online! Click here for The DCC++ EX Team Credits","title":"Thanks"},{"location":"resources/resources/","text":"Resources Work in progress","title":"Resources"},{"location":"resources/resources/#resources","text":"Work in progress","title":"Resources"},{"location":"start/advanced-setup/","text":"Advanced Setup Work in progress","title":"Advanced Setup"},{"location":"start/advanced-setup/#advanced-setup","text":"Work in progress","title":"Advanced Setup"},{"location":"start/assembly/","text":"Assembly Work in progress Jumper Diagrams Next Page: Power Supplies","title":"Assembly"},{"location":"start/assembly/#assembly","text":"Work in progress Jumper Diagrams Next Page: Power Supplies","title":"Assembly"},{"location":"start/automation/","text":"Automation Work in progress","title":"Automation"},{"location":"start/automation/#automation","text":"Work in progress","title":"Automation"},{"location":"start/basic-setup/","text":"Basic Setup Work in progress","title":"Basic Setup"},{"location":"start/basic-setup/#basic-setup","text":"Work in progress","title":"Basic Setup"},{"location":"start/dccpp-jmri/","text":"DCC++ and JMRI Setup Work in progress","title":"JMRI Setup"},{"location":"start/dccpp-jmri/#dcc-and-jmri-setup","text":"Work in progress","title":"DCC++ and JMRI Setup"},{"location":"start/installer-setup/","text":"Installer Setup Work in progress Jumper Diagrams","title":"Installer Setup"},{"location":"start/installer-setup/#installer-setup","text":"Work in progress Jumper Diagrams","title":"Installer Setup"},{"location":"start/rail-networking/","text":"Rail Networking Setup Work in progress","title":"Rail Networking"},{"location":"start/rail-networking/#rail-networking-setup","text":"Work in progress","title":"Rail Networking Setup"},{"location":"start/starter-kit/","text":"DCC++ EX Starter Kit This guide is designed for do-it-yourselfers to build their own system. Anyone can do it, however if you don't feel technically inclined or just want to save the time, you can purchase a starter kit that contains: Controller: A Raspberry Pi with SD Card already configured with everything you need including the JMRI software. Base Station: An Arduino with DCC++ software already uploaded and a Motor Controller Shield prepped and installed Suppliers list coming soon What You Will Need A \"main\" track or \"operations\" - most people already have this, it's your layout A \"programming\" track or \"service\" track - a short section of track that you will use to program locomotives and other pieces of equipment A known-good locomotive equipped with a DCC decoder Equipment List: Hardware A compatible Arduino Board Arduino UNO R3 (clones work too) Arduino Mega (clones work too) Arduino Nano A compatible motor driver shield Arduino Motor Driver Shield Rev 3 (clones work too) Pololu MC33926 Dual Motor Driver Shield (https://www.pololu.com/product/2503) Other boards listed in the hardware section DC Power Supply (see Power Supplies ) USB A to B Cable (aka USB Printer Cable) to connect your Pi or computer to the Arduino A MicroSD Card (for the Raspberry Pi if you choose to use one) Computer to act as a controller to the Arduino Base Station * We recommend: Elegoo Mega 2560 Deek-Robot Motor Shield 12V 5Amp Power Supply Raspberry Pi 4B NOTE: You may use your own computer instead of the Raspberry Pi. However, the image software below saves you installing software on your computer and does a lot more. See: \"My Computer vs. Raspberry Pi\" You can check Amazon, Ebay, AliExpress, Banggood, Adafruit and others for all the above Software DCC++ EX Installer Steve Todd's Raspberry Pi Image JMRI (If you want to use your own computer) Arduino Software IDE to edit and upload changes (Optional) * As mentioned above you can also use your existing computer (PC or MAC) instead of a Pi. You need a computer or Pi to run JMRI and connect to the Arduino to run your trains. A laptop or similar is needed in any case because you are going to need one to download the installer and the Raspebrry Pi image. You will then use it to run the installer to ccopy the program into the Arduino and copy the Raspberry Pi image you download to the MicroSD Card. NOTE: Optionally, you may just use the computer to download and burn the SDCard and then use the Pi to install the firmware onto the Arduino using our Installer. Next Page: Assembly","title":"Starter Kit"},{"location":"start/starter-kit/#dcc-ex-starter-kit","text":"This guide is designed for do-it-yourselfers to build their own system. Anyone can do it, however if you don't feel technically inclined or just want to save the time, you can purchase a starter kit that contains: Controller: A Raspberry Pi with SD Card already configured with everything you need including the JMRI software. Base Station: An Arduino with DCC++ software already uploaded and a Motor Controller Shield prepped and installed Suppliers list coming soon","title":"DCC++ EX Starter Kit"},{"location":"start/starter-kit/#what-you-will-need","text":"A \"main\" track or \"operations\" - most people already have this, it's your layout A \"programming\" track or \"service\" track - a short section of track that you will use to program locomotives and other pieces of equipment A known-good locomotive equipped with a DCC decoder","title":"What You Will Need"},{"location":"start/starter-kit/#equipment-list","text":"","title":"Equipment List:"},{"location":"start/starter-kit/#hardware","text":"A compatible Arduino Board Arduino UNO R3 (clones work too) Arduino Mega (clones work too) Arduino Nano A compatible motor driver shield Arduino Motor Driver Shield Rev 3 (clones work too) Pololu MC33926 Dual Motor Driver Shield (https://www.pololu.com/product/2503) Other boards listed in the hardware section DC Power Supply (see Power Supplies ) USB A to B Cable (aka USB Printer Cable) to connect your Pi or computer to the Arduino A MicroSD Card (for the Raspberry Pi if you choose to use one) Computer to act as a controller to the Arduino Base Station * We recommend: Elegoo Mega 2560 Deek-Robot Motor Shield 12V 5Amp Power Supply Raspberry Pi 4B NOTE: You may use your own computer instead of the Raspberry Pi. However, the image software below saves you installing software on your computer and does a lot more. See: \"My Computer vs. Raspberry Pi\" You can check Amazon, Ebay, AliExpress, Banggood, Adafruit and others for all the above","title":"Hardware"},{"location":"start/starter-kit/#software","text":"DCC++ EX Installer Steve Todd's Raspberry Pi Image JMRI (If you want to use your own computer) Arduino Software IDE to edit and upload changes (Optional) * As mentioned above you can also use your existing computer (PC or MAC) instead of a Pi. You need a computer or Pi to run JMRI and connect to the Arduino to run your trains. A laptop or similar is needed in any case because you are going to need one to download the installer and the Raspebrry Pi image. You will then use it to run the installer to ccopy the program into the Arduino and copy the Raspberry Pi image you download to the MicroSD Card. NOTE: Optionally, you may just use the computer to download and burn the SDCard and then use the Pi to install the firmware onto the Arduino using our Installer. Next Page: Assembly","title":"Software"},{"location":"tinker/tinkering/","text":"Tinker With DCC++ EX Work in progress","title":"Tinker with DCC EX"},{"location":"tinker/tinkering/#tinker-with-dcc-ex","text":"Work in progress","title":"Tinker With DCC++ EX"}]}